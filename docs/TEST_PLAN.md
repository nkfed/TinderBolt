# План тестування (Test Plan)

У цьому документі наведено перелік тестових сценаріїв для основних модулів проєкту: `util.py`, `gpt.py`, `bot.py`, а також перевірки ресурсів (`resources/messages`, `resources/prompts`, `resources/images`).

Формат таблиць:
- Сценарій — короткий опис перевірки
- Вхідні дані — початкові умови та параметри
- Очікуваний результат — перевірюваний результат/поведінка
- Тип тесту — Unit / Integration (Telegram) / Integration (OpenAI) / Resource / E2E (мануально)

Примітка: для інтеграційних тестів із Telegram/OpenAI використовуйте мок‑об’єкти або тестові токени/середовища. Не використовуйте продакшн‑ключі.


## util.py — утилітарні функції та стан діалогу

| Сценарій | Вхідні дані | Очікуваний результат | Тип тесту |
|---|---|---|---|
| send_text: коректний Markdown | Текст без непарної кількості `_` | Виклик `context.bot.send_message(..., parse_mode=MARKDOWN)` з переданим текстом; повертається `Message` | Unit |
| send_text: непарні `_` | Текст з непарною кількістю `_` | Надсилається службове попередження через `update.message.reply_text`; у лог виводиться повідомлення; не викликається `context.bot.send_message` | Unit |
| send_text: сурогатні пари (емодзі) | Текст із емодзі/сурогатами | Текст попередньо перекодовано через UTF‑16 `surrogatepass`, повідомлення доставлено без крашів | Unit |
| send_html: базовий кейс | HTML‑текст, що містить теги | Виклик `context.bot.send_message(..., parse_mode=HTML)`; повертається `Message` | Unit |
| send_text_buttons: побудова клавіатури | Мапа `{"key":"label"}` з 2–3 елементами | Відправляється повідомлення з інлайн‑клавіатурою; `callback_data` відповідає ключам | Unit |
| send_photo: існуюче зображення | Ключ ресурсу `"gpt"` | Відправляється фото з `resources/images/gpt.jpg` | Unit |
| send_photo: відсутнє зображення | Неіснуючий ключ | Акуратна помилка/обробка (очікувана поведінка — зафіксувати й перевірити: виклик винятку або службове повідомлення) | Unit |
| show_main_menu: встановлення команд | Словник команд | Викликаються `set_my_commands` і `set_chat_menu_button` з коректними параметрами | Unit |
| hide_main_menu: скидання меню | — | Меню команд приховане/скинуте (виклики до Telegram API зроблені) | Unit |
| load_message: існуючий файл | Ключ `"gpt"` | Повертається вміст `resources/messages/gpt.txt` | Unit + Resource |
| load_message: відсутній файл | Ключ не існує | Очікувана виняткова ситуація/повідомлення про помилку (залежно від реалізації); тест перевіряє стабільність | Unit + Resource |
| load_prompt: існуючий файл | Ключ `"opener"` | Повертається вміст `resources/prompts/opener.txt` | Unit + Resource |
| dialog_user_info_to_str: лише наявні ключі | Словник із підмножиною ключів | Формується рядок тільки з наявних полів у фіксованому порядку; завершення рядків `\n` | Unit |
| Dialog: початковий стан | Ініціалізація `Dialog()` | `mode is None`, `list == []`, `user == {}`, `counter == 0` | Unit |


## gpt.py — клієнт OpenAI Chat Completions

| Сценарій | Вхідні дані | Очікуваний результат | Тип тесту |
|---|---|---|---|
| __init__: ініціалізація клієнта | Валідний токен (мок) | Створено `openai.OpenAI(base_url=..., api_key=...)`, `message_list` порожній | Unit |
| set_prompt: очищення історії | `prompt_text = "You are..."` | `message_list == [{role: "system", content: prompt}]` | Unit |
| add_message: додає user і шле | `message_text = "Hi"`; мок відповіді | До `message_list` додається `user`, викликається `send_message_list`, повертається контент відповіді | Unit |
| send_message_list: базовий виклик | Попередньо підготовлений `message_list` | Викликається `client.chat.completions.create(model="gpt-4o", messages=..., max_tokens=3000, temperature=0.9)`; відповідь `assistant` додається в `message_list`; повертається `message.content` | Unit |
| send_question: одноразовий запит | `prompt_text`, `message_text` | Історія очищена; у `message_list` рівно два повідомлення: system + user; отримано контент відповіді | Unit |
| обробка помилок OpenAI | Виняток із SDK під час `create()` | Виняток проброшено вгору (або обгорнутий, якщо додасте обробку в майбутньому) | Unit |
| інтеграція з OpenAI Sandbox | Валідний тестовий токен, реальний запит | Отримано ненульову відповідь; ліміти/квоти враховані | Integration (OpenAI) |


## bot.py — хендлери та маршрутизація

Примітка: для unit‑тестів замокайте `ChatGptService`, Telegram `Update/Context` та утиліти з `util.py` (або ізольовано перевіряйте виклики/параметри). Для інтеграції — використовуйте тестовий бот/чат.

| Сценарій | Вхідні дані | Очікуваний результат | Тип тесту |
|---|---|---|---|
| /start: скидання режиму та меню | Команда `/start` | `dialog.mode = None`; надіслані фото `main`, текст `messages/main.txt`; показано головне меню з очікуваними кнопками | Unit / Integration (Telegram) |
| /gpt: активація режиму | Команда `/gpt` | `dialog.mode = "gpt"`; надіслані фото `gpt` і текст інструкції | Unit / Integration (Telegram) |
| gpt_dialog: просте питання | Текст «Hello» при `mode="gpt"` | Завантажено `prompts/gpt.txt`; викликано `chatgpt.send_question(prompt, "Hello")`; відповідь відправлена | Unit |
| /date: показ кнопок персонажів | Команда `/date` | `dialog.mode = "date"`; надіслано фото `date`; показано 5 кнопок `date_*` | Unit / Integration (Telegram) |
| date_button: вибір персонажа | Callback `date_gosling` | Відповідь на callback; надіслано фото `resources/images/date_gosling.jpg`; завантажено відповідний промпт; викликано `chatgpt.set_prompt(prompt)` | Unit |
| date_dialog: діалог із ШІ | Текст «Hi» при `mode="date"` | Спершу службове «набирає повідомлення»; потім `chatgpt.add_message("Hi")`; результатом редагується попереднє повідомлення | Unit |
| /message: підготовка історії | Команда `/message` | `dialog.mode = "message"`; `dialog.list` очищено; показано 2 кнопки `message_next`, `message_date`; надіслано фото | Unit / Integration (Telegram) |
| message_dialog: агрегація | Кілька текстів у `mode="message"` | Кожен текст додається в `dialog.list` у правильному порядку | Unit |
| message_button: генерація відповіді | Callback `message_next` з попередніми повідомленнями | Показано «Думаю над варіантами...», сформовано відповідний промпт (`prompts/message_next.txt` чи `message_date.txt`), викликано `chatgpt.send_question(prompt, "\n".join(dialog.list))`, службове повідомлення відредаговане відповіддю | Unit |
| /profile: запуск опитника | Команда `/profile` | `dialog.mode = "profile"`; `dialog.user` очищено; `dialog.counter = 0`; надіслано перше питання | Unit |
| profile_dialog: послідовність 1–N | Послідовність відповідей (ім’я, вік, зовн., робота, ціль) | На кожен крок інкрементується `dialog.counter`; ключі `name/age/handsome/occupation/goals` збережені; на 5‑му кроці формується `user_info`, виклик `chatgpt.send_question(opener_prompt, user_info)`; відповідь відправлена | Unit |
| /opener: запуск опитника | Команда `/opener` | Аналогічно `/profile` (залежно від реалізації); перевірити ініціалізацію стану | Unit |
| opener_dialog: генерація «першого повідомлення» | 5 відповідей користувача | На 5‑му кроці завантажується `prompts/opener.txt`, формується `user_info`, викликається `chatgpt.send_question`, службове повідомлення редагується | Unit |
| hello: маршрутизація за mode | Різні значення `dialog.mode` | Викликається саме той діалоговий хендлер, який відповідає режиму | Unit |
| buttons_handler: довільні кнопки | Callback `start`/`stop` | Відправляє «Started»/«Stopped» відповідно | Unit |
| Інтеграція з Telegram: smoke | Тестовий бот і чат | Команди `/start`, `/gpt`, `/date` виконуються без падінь; базові медіа/кнопки працюють | Integration (Telegram) |


## Ресурси — валідація узгодженості

| Сценарій | Вхідні дані | Очікуваний результат | Тип тесту |
|---|---|---|---|
| Відповідність messages/*.txt викликам | Перелік файлів у `resources/messages` і виклики `load_message("*")` у коді | Для кожного виклику існує файл; відсутність — помилка тесту | Resource |
| Відповідність prompts/*.txt викликам | Перелік файлів у `resources/prompts` і виклики `load_prompt("*")` | Для кожного виклику існує файл; відсутність — помилка тесту | Resource |
| Невикористані ресурси | Перелік файлів у `resources/messages/prompts` | Виявлені файли, які ніде не згадуються; тест репортує список (не обов’язково падіння, залежно від політики) | Resource |
| Наявність зображень за ключами | Ключі, що передаються у `send_photo(update, context, key)` | Існують відповідні `resources/images/{key}.jpg`; відсутність — помилка | Resource |


## Негативні та крайні випадки (Edge cases)

| Сценарій | Вхідні дані | Очікуваний результат | Тип тесту |
|---|---|---|---|
| Дуже довгі повідомлення до OpenAI | Текст > 4–8К символів | Перевірити, що немає крашу; за потреби обрізання/помилка від API оброблена та донесена до користувача | Unit / Integration (OpenAI) |
| Telegram API error | Імітація 429/500 при відправці | Коректний ретрай/повідомлення користувачу (зараз — відсутній ретрай: тест перевіряє, що помилка не призводить до зависання процесу) | Unit |
| Невалідний Markdown | Текст з непарними `_` | Користувач отримує підказку про `send_html()`; немає падіння | Unit |
| Відсутній prompt/message файл | Ключ без файла | Акуратна помилка/логування; відсутність падіння застосунку (або контрольований виняток, який можна перехопити) | Unit + Resource |
| Змішування режимів | Швидка зміна `/gpt` → `/date` і надсилання тексту | Роутер `hello` надсилає у відповідний активний режим; відсутність побічних ефектів попереднього режиму | Unit |


## Примітки щодо реалізації тестів

- Unit‑тести: рекомендується `pytest` + `pytest-asyncio`; мокання Telegram та OpenAI через `unittest.mock` або `pytest-mock`.
- Integration (Telegram): окремий тестовий бот, ізольований чат; обмежити частоту запитів.
- Integration (OpenAI): використовуйте тестові ключі/квоти; зменшити `max_tokens` у мок‑конфігурації, якщо додаватимете параметризацію.
- Resource‑тести: автоматично інвентаризувати файли в `resources/*` і звіряти з усіма викликами `load_message`/`load_prompt`/`send_photo` у коді.
- E2E: опційно сценарії руками за інструкцією з README (smoke‑прогін команд меню).
